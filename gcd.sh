#!/bin/bash
# gcd.sh: поиск наибольшего общего делителя # по алгоритму Эвклида
# Под "наибольшим общим делителем" (нод) двух целых чисел
#+ понимается наибольшее целое число, которое делит оба делимых без остатка.
# Алгоритм Эвклида выполняет последовательное деление. # В каждом цикле,
#+ делимое <--- делитель
#+ делитель <--- остаток
#+ до тех пор, пока остаток не станет равным нулю (остаток = 0). #+ The gcd = dividend, on the final pass.
# Замечательное описание алгоритма Эвклида можно найти
# на сайте Jim Loy, http://www.jimloy.com/number/euclids.htm.
# ------------------------------------------------------ # Проверка входных параметров
ARGS=2
E_BADARGS=65
if [ $# -ne "$ARGS" ]
then
    echo "Порядок использования: `basename $0` первое-число второе-число"
    exit ${E_BADARGS}
fi
# ------------------------------------------------------
re='^[0-9]+\.[0-9]*$'
re2='^[0-9]+$'
if [[ "$1" =~ $re ]]
then
    echo "Не целое число: $1"
    exit ${E_BADARGS}
fi

if ! [[ "$1" =~ $re2 ]]
then
    echo "Не число: $1"
    exit ${E_BADARGS}
fi

if [[ "$2" =~ $re ]]
then
    echo "Не целое число: $2"
    exit ${E_BADARGS}
fi

if ! [[ "$2" =~ $re2 ]]
then
    echo "Не число: $2"
    exit ${E_BADARGS}
fi
# ------------------------------------------------------
gcd () {
    dividend=$1
    divisor=$2
    remainder=1
    # Начальное присваивание.
    # В сущности, не имеет значения #+ какой из них больше.
    # Почему?
    # Если переменные неинициализировать,
    #+ то работа сценария будет прервана по ошибке #+ в первом же цикле.

    until [ ${remainder} -eq 0 ]
    do
        let "remainder = $dividend % $divisor"
        dividend=${divisor}
        divisor=${remainder}
    done
}
# Повторить цикл с новыми исходными данными # алгоритм Эвклида
# последнее $dividend и есть нод.
gcd $1 $2
echo;
echo "НОД чисел $1 и $2 = $dividend";
echo
exit 0